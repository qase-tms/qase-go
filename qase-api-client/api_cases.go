/*
Qase.io TestOps API v1

Qase TestOps API v1 Specification.

API version: 1.0.0
Contact: support@qase.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api_v1_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CasesAPIService CasesAPI service
type CasesAPIService service

type ApiBulkRequest struct {
	ctx          context.Context
	ApiService   *CasesAPIService
	code         string
	testCasebulk *TestCasebulk
}

func (r ApiBulkRequest) TestCasebulk(testCasebulk TestCasebulk) ApiBulkRequest {
	r.testCasebulk = &testCasebulk
	return r
}

func (r ApiBulkRequest) Execute() (*Bulk200Response, *http.Response, error) {
	return r.ApiService.BulkExecute(r)
}

/*
Bulk Create test cases in bulk

This method allows to bulk create new test cases in a project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@return ApiBulkRequest
*/
func (a *CasesAPIService) Bulk(ctx context.Context, code string) ApiBulkRequest {
	return ApiBulkRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
	}
}

// Execute executes the request
//
//	@return Bulk200Response
func (a *CasesAPIService) BulkExecute(r ApiBulkRequest) (*Bulk200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Bulk200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.Bulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}
	if r.testCasebulk == nil {
		return localVarReturnValue, nil, reportError("testCasebulk is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testCasebulk
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCaseAttachExternalIssueRequest struct {
	ctx                    context.Context
	ApiService             *CasesAPIService
	code                   string
	testCaseexternalIssues *TestCaseexternalIssues
}

func (r ApiCaseAttachExternalIssueRequest) TestCaseexternalIssues(testCaseexternalIssues TestCaseexternalIssues) ApiCaseAttachExternalIssueRequest {
	r.testCaseexternalIssues = &testCaseexternalIssues
	return r
}

func (r ApiCaseAttachExternalIssueRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.CaseAttachExternalIssueExecute(r)
}

/*
CaseAttachExternalIssue Attach the external issues to the test cases

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@return ApiCaseAttachExternalIssueRequest
*/
func (a *CasesAPIService) CaseAttachExternalIssue(ctx context.Context, code string) ApiCaseAttachExternalIssueRequest {
	return ApiCaseAttachExternalIssueRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *CasesAPIService) CaseAttachExternalIssueExecute(r ApiCaseAttachExternalIssueRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.CaseAttachExternalIssue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}/external-issue/attach"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}
	if r.testCaseexternalIssues == nil {
		return localVarReturnValue, nil, reportError("testCaseexternalIssues is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testCaseexternalIssues
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCaseDetachExternalIssueRequest struct {
	ctx                    context.Context
	ApiService             *CasesAPIService
	code                   string
	testCaseexternalIssues *TestCaseexternalIssues
}

func (r ApiCaseDetachExternalIssueRequest) TestCaseexternalIssues(testCaseexternalIssues TestCaseexternalIssues) ApiCaseDetachExternalIssueRequest {
	r.testCaseexternalIssues = &testCaseexternalIssues
	return r
}

func (r ApiCaseDetachExternalIssueRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.CaseDetachExternalIssueExecute(r)
}

/*
CaseDetachExternalIssue Detach the external issues from the test cases

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@return ApiCaseDetachExternalIssueRequest
*/
func (a *CasesAPIService) CaseDetachExternalIssue(ctx context.Context, code string) ApiCaseDetachExternalIssueRequest {
	return ApiCaseDetachExternalIssueRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *CasesAPIService) CaseDetachExternalIssueExecute(r ApiCaseDetachExternalIssueRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.CaseDetachExternalIssue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}/external-issue/detach"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}
	if r.testCaseexternalIssues == nil {
		return localVarReturnValue, nil, reportError("testCaseexternalIssues is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testCaseexternalIssues
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCaseRequest struct {
	ctx            context.Context
	ApiService     *CasesAPIService
	code           string
	testCaseCreate *TestCaseCreate
}

func (r ApiCreateCaseRequest) TestCaseCreate(testCaseCreate TestCaseCreate) ApiCreateCaseRequest {
	r.testCaseCreate = &testCaseCreate
	return r
}

func (r ApiCreateCaseRequest) Execute() (*IdResponse, *http.Response, error) {
	return r.ApiService.CreateCaseExecute(r)
}

/*
CreateCase Create a new test case

This method allows to create a new test case in selected project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@return ApiCreateCaseRequest
*/
func (a *CasesAPIService) CreateCase(ctx context.Context, code string) ApiCreateCaseRequest {
	return ApiCreateCaseRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
	}
}

// Execute executes the request
//
//	@return IdResponse
func (a *CasesAPIService) CreateCaseExecute(r ApiCreateCaseRequest) (*IdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.CreateCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}
	if r.testCaseCreate == nil {
		return localVarReturnValue, nil, reportError("testCaseCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testCaseCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCaseRequest struct {
	ctx        context.Context
	ApiService *CasesAPIService
	code       string
	id         int32
}

func (r ApiDeleteCaseRequest) Execute() (*IdResponse, *http.Response, error) {
	return r.ApiService.DeleteCaseExecute(r)
}

/*
DeleteCase Delete test case

This method completely deletes a test case from repository.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@param id Identifier.
	@return ApiDeleteCaseRequest
*/
func (a *CasesAPIService) DeleteCase(ctx context.Context, code string, id int32) ApiDeleteCaseRequest {
	return ApiDeleteCaseRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IdResponse
func (a *CasesAPIService) DeleteCaseExecute(r ApiDeleteCaseRequest) (*IdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.DeleteCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCaseRequest struct {
	ctx        context.Context
	ApiService *CasesAPIService
	code       string
	id         int32
	include    *string
}

// A list of entities to include in response separated by comma. Possible values: external_issues.
func (r ApiGetCaseRequest) Include(include string) ApiGetCaseRequest {
	r.include = &include
	return r
}

func (r ApiGetCaseRequest) Execute() (*TestCaseResponse, *http.Response, error) {
	return r.ApiService.GetCaseExecute(r)
}

/*
GetCase Get a specific test case

This method allows to retrieve a specific test case.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@param id Identifier.
	@return ApiGetCaseRequest
*/
func (a *CasesAPIService) GetCase(ctx context.Context, code string, id int32) ApiGetCaseRequest {
	return ApiGetCaseRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
		id:         id,
	}
}

// Execute executes the request
//
//	@return TestCaseResponse
func (a *CasesAPIService) GetCaseExecute(r ApiGetCaseRequest) (*TestCaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TestCaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.GetCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCasesRequest struct {
	ctx                context.Context
	ApiService         *CasesAPIService
	code               string
	search             *string
	milestoneId        *int32
	suiteId            *int32
	severity           *string
	priority           *string
	type_              *string
	behavior           *string
	automation         *string
	status             *string
	externalIssuesType *string
	externalIssuesIds  *[]string
	include            *string
	limit              *int32
	offset             *int32
}

// Provide a string that will be used to search by name.
func (r ApiGetCasesRequest) Search(search string) ApiGetCasesRequest {
	r.search = &search
	return r
}

// ID of milestone.
func (r ApiGetCasesRequest) MilestoneId(milestoneId int32) ApiGetCasesRequest {
	r.milestoneId = &milestoneId
	return r
}

// ID of test suite.
func (r ApiGetCasesRequest) SuiteId(suiteId int32) ApiGetCasesRequest {
	r.suiteId = &suiteId
	return r
}

// A list of severity values separated by comma. Possible values: undefined, blocker, critical, major, normal, minor, trivial
func (r ApiGetCasesRequest) Severity(severity string) ApiGetCasesRequest {
	r.severity = &severity
	return r
}

// A list of priority values separated by comma. Possible values: undefined, high, medium, low
func (r ApiGetCasesRequest) Priority(priority string) ApiGetCasesRequest {
	r.priority = &priority
	return r
}

// A list of type values separated by comma. Possible values: other, functional smoke, regression, security, usability, performance, acceptance
func (r ApiGetCasesRequest) Type_(type_ string) ApiGetCasesRequest {
	r.type_ = &type_
	return r
}

// A list of behavior values separated by comma. Possible values: undefined, positive negative, destructive
func (r ApiGetCasesRequest) Behavior(behavior string) ApiGetCasesRequest {
	r.behavior = &behavior
	return r
}

// A list of values separated by comma. Possible values: is-not-automated, automated to-be-automated
func (r ApiGetCasesRequest) Automation(automation string) ApiGetCasesRequest {
	r.automation = &automation
	return r
}

// A list of values separated by comma. Possible values: actual, draft deprecated
func (r ApiGetCasesRequest) Status(status string) ApiGetCasesRequest {
	r.status = &status
	return r
}

// An integration type.
func (r ApiGetCasesRequest) ExternalIssuesType(externalIssuesType string) ApiGetCasesRequest {
	r.externalIssuesType = &externalIssuesType
	return r
}

// A list of issue IDs.
func (r ApiGetCasesRequest) ExternalIssuesIds(externalIssuesIds []string) ApiGetCasesRequest {
	r.externalIssuesIds = &externalIssuesIds
	return r
}

// A list of entities to include in response separated by comma. Possible values: external_issues.
func (r ApiGetCasesRequest) Include(include string) ApiGetCasesRequest {
	r.include = &include
	return r
}

// A number of entities in result set.
func (r ApiGetCasesRequest) Limit(limit int32) ApiGetCasesRequest {
	r.limit = &limit
	return r
}

// How many entities should be skipped.
func (r ApiGetCasesRequest) Offset(offset int32) ApiGetCasesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetCasesRequest) Execute() (*TestCaseListResponse, *http.Response, error) {
	return r.ApiService.GetCasesExecute(r)
}

/*
GetCases Get all test cases

This method allows to retrieve all test cases stored in selected project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@return ApiGetCasesRequest
*/
func (a *CasesAPIService) GetCases(ctx context.Context, code string) ApiGetCasesRequest {
	return ApiGetCasesRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
	}
}

// Execute executes the request
//
//	@return TestCaseListResponse
func (a *CasesAPIService) GetCasesExecute(r ApiGetCasesRequest) (*TestCaseListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TestCaseListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.GetCases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.milestoneId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "milestone_id", r.milestoneId, "")
	}
	if r.suiteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suite_id", r.suiteId, "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "")
	}
	if r.priority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "priority", r.priority, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.behavior != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "behavior", r.behavior, "")
	}
	if r.automation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "automation", r.automation, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.externalIssuesType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "external_issues[type]", r.externalIssuesType, "")
	}
	if r.externalIssuesIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "external_issues[ids][]", r.externalIssuesIds, "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCaseRequest struct {
	ctx            context.Context
	ApiService     *CasesAPIService
	code           string
	id             int32
	testCaseUpdate *TestCaseUpdate
}

func (r ApiUpdateCaseRequest) TestCaseUpdate(testCaseUpdate TestCaseUpdate) ApiUpdateCaseRequest {
	r.testCaseUpdate = &testCaseUpdate
	return r
}

func (r ApiUpdateCaseRequest) Execute() (*IdResponse, *http.Response, error) {
	return r.ApiService.UpdateCaseExecute(r)
}

/*
UpdateCase Update test case

This method updates a test case.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param code Code of project, where to search entities.
	@param id Identifier.
	@return ApiUpdateCaseRequest
*/
func (a *CasesAPIService) UpdateCase(ctx context.Context, code string, id int32) ApiUpdateCaseRequest {
	return ApiUpdateCaseRequest{
		ApiService: a,
		ctx:        ctx,
		code:       code,
		id:         id,
	}
}

// Execute executes the request
//
//	@return IdResponse
func (a *CasesAPIService) UpdateCaseExecute(r ApiUpdateCaseRequest) (*IdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *IdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CasesAPIService.UpdateCase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/case/{code}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"code"+"}", url.PathEscape(parameterValueToString(r.code, "code")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.code) < 2 {
		return localVarReturnValue, nil, reportError("code must have at least 2 elements")
	}
	if strlen(r.code) > 10 {
		return localVarReturnValue, nil, reportError("code must have less than 10 elements")
	}
	if r.testCaseUpdate == nil {
		return localVarReturnValue, nil, reportError("testCaseUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.testCaseUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
